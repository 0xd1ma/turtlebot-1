# turtlebot-net-down: things turtlebot needs to happen whenever a network interface goes down.
#
# Whenever a network interface goes down, we want to stop the current
# turtlebot session.  If the stack of valid network interfaces has any
# left, start a new session on the last interface from the stack.
#
# This is not a total solution to 100% ROS availability, but it is a
# start which should work well enough for demos.

start on net-device-down

task
console output

emits turtlebot-session-end
emits turtlebot-session-begin

script
    interface=$IFACE

    stack_file=/tmp/turtlebot-network-interface-stack
    initctl="/sbin/initctl"

    # We don't care about the loopback interface.
    if [ "$interface" = "lo" ]; then
        exit 0
    fi

    # If the stack is empty or missing, we have nothing to do.
    if [ ! -s $stack_file ]; then
        exit 0
    fi

    last_entry=`tail -1 $stack_file`

    # Remove the interface from the stack.  The "|| true" makes the grep
    # line return "success" even if $interface was the only line in the
    # file (in other words, if "grep -v" did not succeed in finding any
    # lines without $interface.
    grep -v "^$interface\$" < $stack_file > $stack_file.new || true
    mv $stack_file.new $stack_file

    # If we are removing the entry at the end of the stack, we need to end
    # that session.
    if [ "$last_entry" = "$interface" ]; then
        $initctl emit turtlebot-session-end

        # If there is still something in the stack, start a session based
        # on the most recent interface.
        if [ -s $stack_file ]; then
            new_interface=`tail -1 $stack_file`
            $initctl emit turtlebot-session-begin IFACE=$new_interface
        fi
    fi
end script
